name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      dry_run:
        description: 'Dry run (no actual release)'
        required: false
        default: true
        type: boolean

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for conventional-changelog
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine
    
    - name: Get current version
      id: current_version
      run: |
        CURRENT_VERSION=$(python -c "import smart_gpu; print(smart_gpu.__version__)")
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
    
    - name: Calculate new version
      id: new_version
      run: |
        CURRENT_VERSION=${{ steps.current_version.outputs.current_version }}
        RELEASE_TYPE=${{ github.event.inputs.release_type }}
        
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        case $RELEASE_TYPE in
          "major")
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="$NEW_MAJOR.0.0"
            ;;
          "minor")
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="$MAJOR.$NEW_MINOR.0"
            ;;
          "patch")
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            ;;
        esac
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"
        echo "New version: $NEW_VERSION"
    
    - name: Update version files
      run: |
        NEW_VERSION=${{ steps.new_version.outputs.new_version }}
        
        # Update pyproject.toml
        sed -i "s/version = \".*\"/version = \"$NEW_VERSION\"/" pyproject.toml
        
        # Update __init__.py
        sed -i "s/__version__ = \".*\"/__version__ = \"$NEW_VERSION\"/" src/smart_gpu/__init__.py
        
        # Update CHANGELOG.md
        sed -i "s/## \[Unreleased\]/## [Unreleased]\n\n## [$NEW_VERSION] - $(date +%Y-%m-%d)/" CHANGELOG.md
    
    - name: Build package
      run: |
        python -m build
    
    - name: Check package
      run: |
        twine check dist/*
    
    - name: Test package installation
      run: |
        pip install dist/smart_gpu-*.whl
        python -c "import smart_gpu; print(f'Successfully installed smart-gpu {smart_gpu.__version__}')"
    
    - name: Create Pull Request (Dry Run)
      if: github.event.inputs.dry_run == 'true'
      run: |
        echo "DRY RUN: Would create PR with version ${{ steps.new_version.outputs.new_version }}"
        echo "Files that would be updated:"
        echo "- pyproject.toml"
        echo "- src/smart_gpu/__init__.py"
        echo "- CHANGELOG.md"
        echo ""
        echo "To create actual release:"
        echo "1. Set dry_run to false"
        echo "2. Run this workflow again"
        echo "3. Create and push a tag: git tag v${{ steps.new_version.outputs.new_version }}"
        echo "4. Push the tag: git push origin v${{ steps.new_version.outputs.new_version }}"
    
    - name: Commit and push changes
      if: github.event.inputs.dry_run == 'false'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add pyproject.toml src/smart_gpu/__init__.py CHANGELOG.md
        git commit -m "Bump version to ${{ steps.new_version.outputs.new_version }}"
        git tag v${{ steps.new_version.outputs.new_version }}
        git push origin main
        git push origin v${{ steps.new_version.outputs.new_version }}"
